from z3 import *
import copy
import time

start_total = time.time()

# 变量，要用在z3检验过程中的
X = Int('X')    
Y = Int('Y')
X1 = Int('X1')
Y1 = Int('Y1')
k_num = Int('k_num')
#
c = Int('c')
d = Int('d')
# -----------------------------------------------------------
# The operator that the enumrate algorithm used
# 枚举要用到的符号 放在FunExg 和 Z3FunExg中
# 用函数来表示，就可以直接从字典中调用了


def Add(a, b):
    return a+b


def Sub(a, b):
    return a-b


def Inc(a):
    a = a+1
    return a


def Dec(a):
    a = a - 1
    return a


def Mod(a, b):
    return a % b


def Ge(a, b):
    return a >= b


def Gt(a, b):
    return a > b


def Equal(a, b):
    return a == b


def Unequal(a, b):
    return a != b


def OR(a, b):
    return (a or b)


def z3OR(a, b):
    return Or(a, b)


def AND(a, b):
    return (a and b)


def z3AND(a, b):
    return And(a, b)


def NOT(a):
    return (not a)


def z3NOT(a):
    return Not(a)


def Zero():
    return 0


def One():
    return 1


def Two():
    return 2


def Three():
    return 3


def Four():
    return 4


def Five():
    return 5


def Six():
    return 6


def Seven():
    return 7


def Eight():
    return 8


def Nine():
    return 9


def ModTest(a, b, c):
    return a % b == c
# -----------------------------------------------------------------


# The game you need input, the can be generated by PDDL, here is an example

# Chomp game(2 x n)
# 字典数组action game
# 游戏初始化，终结条件，动作，约束，变量数量，appeal_constants（基本的常数量，一般只有0,1，0，1就可以靠运算代表所有的数字）
# 动作，动作名，前提，转移公式(约束的组成部分)  translation_formula And(pre,v'==k-1,eff,frame axiom)
# actions = [{"action_name": "eat1", "precondition": And(X >= k_num, k_num > 1), "transition_formula": And(And(X >= k_num, k_num > 1), Y == k_num - 1, Implies(X1 >= k_num, Y1 == k_num - 1), Or(X1 >= k_num, Y1 == X1))},
#            {"action_name": "eat2", "precondition": And(X1 >= k_num, k_num > 0), "transition_formula": And(And(X1 >= k_num, k_num > 0), Y1 == k_num - 1, Y == X)}]
# Game = {"Terminal_Condition": And(X == 1, X1 == 0),
#         "actions": actions,
#         "Constraint": And(X >= 1, X1 >= 0, X >= X1),
#         "var_num": 2,
#         "appeal_constants": []}


# empty and divide
actions = [{"action_name": "empty1", "precondition": And(X1 > k_num, k_num >= 1), "transition_formula": And(And(X1 > k_num, k_num >= 1), And(Y == k_num, Y1 == X1 - k_num))},
           {"action_name": "empty2", "precondition": And(X > k_num, k_num >= 1), "transition_formula": And(And(X > k_num, k_num >= 1), And(Y1 == k_num, Y == X - k_num))}]
Game = {"Terminal_Condition": And(X == 1, X1 == 1),
        "actions": actions,
        "Constraint": And(X >= 1, X1 >= 1),
        "var_num": 2,
        "appeal_constants": []}

# actions = [{"action_name": "take1", "precondition": Or(And(k_num == 1, X > 0), And(k_num == 2, X > 1)), "transition_formula": And(Or(And(k_num == 1, X > 0), And(k_num == 2, X > 1)), Y == X - k_num, Y1 == X1)},
#            {"action_name": "take2", "precondition": Or(And(k_num == 1, X1 > X), And(k_num == 2, X1 > X + 1)), "transition_formula": And(Or(And(k_num == 1, X1 > X), And(k_num == 2, X1 > X + 1)), Y1 == X1-k_num, Y == X)},
#            {"action_name": "takeBoth", "precondition": And(X == X1, X > 0), "transition_formula": And(And(X == X1, X > 0), Y == X-1, Y1 == X1-1)}]
# Game = {"Terminal_Condition": And(X == 0, X1 == 0),
#         "actions": actions,
#         "Constraint": And(X >= 0, X1 >= X),
#         "var_num": 2,
#         "appeal_constants": []}

NUMBER_CONSTANT = {1: "One", 2: "Two", 3: "Three", 4: "Four", 5: "Five", 6: "Six", 7: "Seven",
                   8: "Eight", 9: "Nine"}

# 计算用的函数，枚举用的形式：
vocabulary = [{'Input': ['Int', 'Int'], 'Output':'Int', 'Function_name':'Add', 'arity':2},
              {'Input': ['Int', 'Int'], 'Output': 'Int',
                  'Function_name': 'Sub', 'arity':2},
              {'Input': ['Int'], 'Output': 'Int',
                  'Function_name': 'Inc', 'arity':1},
              {'Input': ['Int'], 'Output': 'Int',
                  'Function_name': 'Dec', 'arity':1},
              {'Input': ['Int', 'Int'], 'Output': 'Bool',
                  'Function_name': 'Equal', 'arity': 2},
              {'Input': ['Int', 'Int'], 'Output': 'Bool',
                  'Function_name': 'Unequal', 'arity': 2},
              {'Input': ['Int', 'Int'], 'Output': 'Bool',
                  'Function_name': 'Ge', 'arity':2},
              {'Input': ['Int', 'Int'], 'Output': 'Bool',
                  'Function_name': 'Gt', 'arity':2},
              {'Input': ['Bool', 'Bool'], 'Output': 'Bool',
                  'Function_name': 'OR', 'arity': 2},
              {'Input': ['Bool', 'Bool'], 'Output': 'Bool',
                  'Function_name': 'AND', 'arity': 2},
              {'Input': [], 'Output': 'Int', 'Function_name': 'Zero', 'arity': 0},
              {'Input': [], 'Output': 'Int', 'Function_name': 'One', 'arity': 0},
              {'Input': ['Int', 'Int', 'Int'], 'Output':'Bool', 'Function_name':'ModTest', 'arity':3}]

# 想加入基本的常数，就添加的字典中，根据游戏的特性决定
for i in Game["appeal_constants"]:
    vocabulary.append({'Input': [], 'Output': 'Int',
                       'Function_name': NUMBER_CONSTANT[i], 'arity': 0},)


# The goal that the enumerate algorithm generated
goal = {'value': [], 'type': ''}
# 函数名称字典，调用是加个（）即可表示具体的函数
FunExg = {'Add': Add, 'Sub': Sub, 'Inc': Inc, 'Dec': Dec, 'Ge': Ge,
          'Gt': Gt, 'OR': OR, 'AND': AND, 'NOT': NOT, 'Equal': Equal, 'Mod': Mod,
          'Unequal': Unequal, 'X': X, 'Y': Y, 'Zero': Zero, 'One': One, 'ModTest': ModTest}
print(FunExg['One']())
# 存在两个变量就添加到funexg中，之后好调用
if(Game["var_num"] == 2):
    FunExg['X1'] = X1
    FunExg['Y1'] = Y1
# eval字符串方式输入表达式给z3solver
for i in Game["appeal_constants"]:
    FunExg[NUMBER_CONSTANT[i]] = eval(NUMBER_CONSTANT[i])
Z3FunExg = {'Add': Add, 'Sub': Sub, 'Inc': Inc, 'Dec': Dec, 'Ge': Ge,
            'Gt': Gt, 'OR': z3OR, 'AND': z3AND, 'NOT': z3NOT, 'Equal': Equal, 'Mod': Mod,
            'Unequal': Unequal, 'X': X, 'Y': Y, 'Zero': Zero, 'One': One, 'ModTest': ModTest}
if(Game["var_num"] == 2):
    Z3FunExg['X1'] = X1
    Z3FunExg['Y1'] = Y1
for i in Game["appeal_constants"]:
    Z3FunExg[NUMBER_CONSTANT[i]] = eval(NUMBER_CONSTANT[i])


ConcreteExs = []  # 反例集合

start_winning_formula_time = time.time()

# The enumerative algorithm for multiple objects
# [X==X,Y==Y]
# 枚举算法 输入vocabulation,concreteExs,sizeoneEXps,
# 输出e满足反例集合 z3表达式


# E_A(num,'Bool')  Enumerate_algorithm(it_mum,'Int')
def Enumerate_algorithm(count, Goal_type):
    goal['type'] = Goal_type
    # signatures 记录是否枚举过了 (e,concreteEXp)  [2,2,2,2][TTFT]反例集合几个数就大小多少
    SigSet = []
    ExpSet = []  # set of expression（type t size i）
    SizeOneExps = []
    # 初始化大小为1的表达式  arity变量数目 size输出的大小
    SizeOneExps.append({'Input': ['Int'], 'Output': 'Int', 'Expression': 'X', 'z3Expression': [
                       X, Y], 'arity': 1, 'size': 1})
    if(Game["var_num"] == 2):
        SizeOneExps.append({'Input': ['Int'], 'Output': 'Int', 'Expression': 'X1', 'z3Expression': [
                           X1, Y1], 'arity': 1, 'size': 1})
    SizeOneExps.append({'Input': [], 'Output': 'Int', 'Expression': 'Zero',
                        'z3Expression': [Zero(), Zero()], 'arity': 0, 'size': 1})
    SizeOneExps.append({'Input': [], 'Output': 'Int', 'Expression': 'One',
                        'z3Expression': [One(), One()], 'arity': 0, 'size': 1})
    for i in Game["appeal_constants"]:
        SizeOneExps.append({'Input': [], 'Output': 'Int', 'Expression': NUMBER_CONSTANT[i], 'z3Expression': [
                           eval(NUMBER_CONSTANT[i])(), eval(NUMBER_CONSTANT[i])()], 'arity': 0, 'size': 1})

    # 先枚举大小1的表达式（常数，单个变量），看是否满足goal
    for i in SizeOneExps:
        Goal1 = []
        if (i['arity'] == 0):  # 数字
            for num in range(count):  # count反例数
                Goal1.append(FunExg[i['Expression']]())
            if Goal1 not in SigSet:  # Sigset标记
                SigSet.append(Goal1)
                i['Output_data'] = Goal1
                ExpSet.append(i)  # 表达式添加一个输出项，将表达式加到表达式集合中
                if Goal1 == goal['value'] and i['Output'] == goal['type']:
                    return i['z3Expression']   # z3 [0,0] [1,1]
        else:
            if i['Expression'] == 'X':  # 开始时反例集合为空
                for j in ConcreteExs:  # 把反例集中的所有的c d都添加入sigset
                   # 反例[{'Input': {c: 3, d: 0}, 'Output': 2}] 致胜策略
                   # X<-c   x1<-d
                    # print(ConcreteExs)
                    O = j['Input'][c]  # c
                    Goal1.append(O)
                if Goal1 not in SigSet:
                    SigSet.append(Goal1)  # SigSet 保留不同的Goal1
                    i['Output_data'] = Goal1
                    ExpSet.append(i)  # size_one_表达式 添加到 EXPset
                    if Goal1 == goal['value'] and i['Output'] == goal['type']:  # 检验是否和goal相等
                        return i['z3Expression']  # [X,Y]
            if i['Expression'] == 'X1':
                for j in ConcreteExs:
                    O = j['Input'][d]  # d
                    Goal1.append(O)
                if Goal1 not in SigSet:
                    SigSet.append(Goal1)
                    i['Output_data'] = Goal1
                    ExpSet.append(i)
                    if Goal1 == goal['value'] and i['Output'] == goal['type']:

                        #print(i['z3Expression']) [X1,Y1]
                        return i['z3Expression']

    for i in vocabulary:
        if (i['arity'] == 1):  # Inc Dec
            # print('199',ExpSet)
            for j in ExpSet:
                if j['size'] == 1:  # 只能取1的表达式来进行+1-1
                    Goal1 = []    #
                    if (i['Input'][0] == j['Output']):  # 要求他们的类型相同
                        TempExp = i['Function_name'] + \
                            '(' + j['Expression'] + ')'  # Inc(x) 是个字符串
                        z3TempExp1 = Z3FunExg[i['Function_name']](
                            j['z3Expression'][0])  # x+1  X是Int('x')
                        z3TempExp2 = Z3FunExg[i['Function_name']](
                            j['z3Expression'][1])  # x+1
                        for k in j['Output_data']:  # [] [2] [2 2] [2 2 1] [2, 2, 1, 2]
                            O = FunExg[i['Function_name']](k)
                            Goal1.append(O)
                        if Goal1 not in SigSet:  # 更新sigset
                            SigSet.append(Goal1)  # 存储枚举的结果的挂号
                            ExpSet.append(
                                {'Input': i['Input'], 'Output': i['Output'], 'Expression': TempExp,
                                 'z3Expression': [z3TempExp1, z3TempExp2], 'arity': i['arity'],
                                 'size': 2, 'Output_data': Goal1})
                            # print("215 expset:",ExpSet)
                        if Goal1 == goal['value'] and i['Output'] == goal['type']:
                            return [z3TempExp1, z3TempExp2]
    li = 3  # 表达式的大小
    while (True):  # 从3开始，找不到一直循环，i+=1
        for i in vocabulary:
            # print("vocabulary",i["Function_name"],"表达式大小:",i['arity'],"---------------------------------------------" )
            # print("305", ExpSet)
            m = i['arity']
            if (m == 1):  # Inc Dec
                for j in ExpSet:
                    # print("232表达式名称",j["Expression"])
                    try:
                        Goal1 = []
                        if ((j['size'] == li - 1) and (i['Input'] == j['Output'])):
                            TempExp = i['Function_name'] + \
                                '(' + j['Expression'] + ')'  # Inc(x)
                            z3TempExp1 = Z3FunExg[i['Function_name']](
                                j['z3Expression'][0])
                            z3TempExp2 = Z3FunExg[i['Function_name']](
                                j['z3Expression'][1])  # [x+1,x+1]
                            for k in j['Output_data']:
                                O = FunExg[i['Function_name']](k)
                                Goal1.append(O)
                            if Goal1 not in SigSet:  # 跟新Sigset才更型ExpSet
                                SigSet.append(Goal1)
                                ExpSet.append({'Input': i['Input'], 'Output': i['Output'],
                                               'Expression': TempExp, 'z3Expression': [z3TempExp1, z3TempExp2],
                                               'arity': i['arity'], 'size': li, 'Output_data': Goal1})
                            # 检验是否满足反例集合
                            if Goal1 == goal['value'] and i['Output'] == goal['type']:
                                return [z3TempExp1, z3TempExp2]
                    except ZeroDivisionError:
                        pass
                    continue
            elif (m == 2):  # add sub
                for num1 in range(1, li - 1):  # 遍历num1+num2=li-1的值
                    for num2 in range(1, li - 1):
                        if (num1 + num2 == li - 1):
                            for choose1 in ExpSet:  # 遍历ExpSet要求size1=num1 size2=num2
                                # print("256表达式1名称",choose1["Expression"])
                                if (choose1['size'] == num1):
                                    for choose2 in ExpSet:
                                        # print("256表达式2名称",choose2["Expression"])
                                        if (choose2['size'] == num2):
                                            if ((i['Input'][0] == choose1['Output']) and (  # 条件是两输入的类型必须满足输出的
                                                    i['Input'][1] == choose2['Output'])):
                                                try:
                                                    Goal1 = []
                                                    TempExp = ''
                                                    # add(x,y)
                                                    # print(i['Function_name'], choose1['Expression'], choose2['Expression'])
                                                    TempExp = i['Function_name'] + \
                                                        '(' + choose1['Expression'] + \
                                                        ',' + \
                                                        choose2['Expression'] + ')'
                                                    z3TempExp1 = Z3FunExg[i['Function_name']](
                                                        choose1['z3Expression'][0], choose2['z3Expression'][0])
                                                    z3TempExp2 = Z3FunExg[i['Function_name']](
                                                        choose1['z3Expression'][1], choose2['z3Expression'][1])
                                                    # 更型Goal1 zip成（a，b）
                                                    for k, h in zip(choose1['Output_data'], choose2['Output_data']):
                                                        O = FunExg[i['Function_name']](
                                                            k, h)
                                                        # print('258',i['Function_name'],choose1['Expression'],choose1['Output_data'],choose2['Expression'],choose2['Output_data'],O)
                                                        # goal={e,concertExs}  [True, True, True]
                                                        Goal1.append(O)
                                                    # print('260',Goal1)
                                                    if Goal1 not in SigSet:
                                                        SigSet.append(Goal1)
                                                        ExpSet.append(
                                                            {'Input': i['Input'], 'Output': i['Output'],
                                                             'Expression': TempExp, 'z3Expression': [z3TempExp1, z3TempExp2],
                                                             'arity': i['arity'], 'size': li, 'Output_data': Goal1})
                                                    # print(SigSet)
                                                    if Goal1 == goal['value'] and i['Output'] == goal['type']:
                                                        # print(ExpSet)
                                                        return [z3TempExp1, z3TempExp2]
                                                except ZeroDivisionError:
                                                    pass
                                                continue
            elif (m == 3):  # 只有ModTest操作
                if (i['Function_name'] == 'ModTest'):
                    for num1 in range(1, li - 1):
                        for num2 in range(1, li - 1):
                            for num3 in range(1, li - 1):
                                if (num1 + num2 + num3 == li - 1):  # 遍历出合适的num1,num2,num3
                                    for choose1 in ExpSet:
                                        if (choose1['size'] == num1):
                                            for choose2 in ExpSet:
                                                if (choose2['size'] == num2):
                                                    for choose3 in ExpSet:
                                                        # 遍历出三个大小合适的表达式
                                                        if (choose3['size'] == num3 and choose3['arity'] == 0):
                                                            if ((i['Input'][0] == choose1['Output']) and (i['Input'][1] == choose2['Output']) and (i['Input'][2] == choose3['Output'])):
                                                                try:
                                                                    Goal1 = []
                                                                    TempExp = ''
                                                                    TempExp = i['Function_name'] + '(' + choose1['Expression'] + \
                                                                        ',' + \
                                                                        choose2['Expression'] + ',' + \
                                                                        choose3['Expression'] + ')'
                                                                    z3TempExp1 = Z3FunExg[i['Function_name']](
                                                                        choose1['z3Expression'][0], choose2['z3Expression'][0], choose3['z3Expression'][0])
                                                                    z3TempExp2 = Z3FunExg[i['Function_name']](
                                                                        choose1['z3Expression'][1], choose2['z3Expression'][1], choose3['z3Expression'][1])
                                                                    for k, h, g in zip(choose1['Output_data'], choose2['Output_data'], choose3['Output_data']):
                                                                        O = FunExg[i['Function_name']](
                                                                            k, h, g)
                                                                        Goal1.append(
                                                                            O)
                                                                    if Goal1 not in SigSet:
                                                                        SigSet.append(
                                                                            Goal1)
                                                                        ExpSet.append({'Input': i['Input'], 'Output': i['Output'],
                                                                                       'Expression': TempExp, 'z3Expression': [z3TempExp1, z3TempExp2],
                                                                                       'arity': i['arity'], 'size': li, 'Output_data': Goal1})
                                                                    if Goal1 == goal['value'] and i['Output'] == goal['type']:
                                                                        return [z3TempExp1, z3TempExp2]
                                                                except ZeroDivisionError:
                                                                    pass
                                                                continue
                else:
                    for num1 in range(1, li - 1):
                        for num2 in range(1, li - 1):
                            for num3 in range(1, li - 1):
                                if (num1 + num2 + num3 == li - 1):
                                    for choose1 in ExpSet:
                                        if (choose1['size'] == num1):
                                            for choose2 in ExpSet:
                                                if (choose2['size'] == num2):
                                                    for choose3 in ExpSet:
                                                        if (choose3['size'] == num3):
                                                            if ((i['Input'][0] == choose1['Output']) and (i['Input'][1] == choose2['Output']) and (i['Input'][2] == choose3['Output'])):
                                                                try:
                                                                    Goal1 = []
                                                                    TempExp = ''
                                                                    TempExp = i['Function_name'] + '(' + choose1['Expression'] + \
                                                                        ',' + \
                                                                        choose2['Expression'] + ',' + \
                                                                        choose3['Expression'] + ')'
                                                                    z3TempExp1 = Z3FunExg[i['Function_name']](
                                                                        choose1['z3Expression'][0], choose2['z3Expression'][0], choose3['z3Expression'][0])
                                                                    z3TempExp2 = Z3FunExg[i['Function_name']](
                                                                        choose1['z3Expression'][1], choose2['z3Expression'][1], choose3['z3Expression'][1])
                                                                    for k, h, g in zip(choose1['Output_data'], choose2['Output_data'], choose3['Output_data']):
                                                                        O = FunExg[i['Function_name']](
                                                                            k, h, g)
                                                                        # print('327',O)
                                                                        Goal1.append(
                                                                            O)
                                                                    if Goal1 not in SigSet:
                                                                        SigSet.append(
                                                                            Goal1)
                                                                        ExpSet.append({'Input': i['Input'], 'Output': i['Output'],
                                                                                       'Expression': TempExp, 'z3Expression': [z3TempExp1, z3TempExp2],
                                                                                       'arity': i['arity'], 'size': li, 'Output_data': Goal1})
                                                                    if Goal1 == goal['value'] and i['Output'] == goal['type']:
                                                                        return [z3TempExp1, z3TempExp2]
                                                                except ZeroDivisionError:
                                                                    pass
                                                                continue

        li = li+1


# 全局转换公式
global_transition_formula = "Exists(k_num,Or("
for i in Game["actions"]:
    global_transition_formula = global_transition_formula + \
        str(i["transition_formula"])+","
global_transition_formula = global_transition_formula+"))"
# print("全局转换公式是：")
# print(global_transition_formula)
global_transition_formula = eval(global_transition_formula)


position_1 = []  # 一个变量
for i in range(0, 100):
    position_1.append('illegal')

position_2 = []  # 两个变量的状态，初始为illegal 在一个范围内找规则
for i in range(0, 100):
    position_2.append([])
    for j in range(0, 100):
        position_2[i].append('illegal')

s = Solver()  # s是z3求解器
s.add(Game["Terminal_Condition"])  # [X1 = 0, X = 1]  必败态设为true 递归出其他所有的状态
s.check()  # sat unsat
m = s.model()  # 模型解
if(Game["var_num"] == 1):
    position_1[m[X].as_long()] = True  # as_long 变为z3Int变为int
if(Game["var_num"] == 2):
    position_2[m[X].as_long()][m[X1].as_long()] = True

# 此函数是一种递归算法，用于查找状态是获胜状态还是失败状态 根据终结条件递归出全部状态
# This function is an recursive algorithm that to find whether a state is a winning state or a losing state


def isLossingState(*v):  # 接受1或者2个参数的元组 根据终结条件去判断是否是lossing_state
    if (len(v) == 1):
        if (position_1[v[0]] != 'illegal'):
            return position_1[v[0]]
        for x in range(0, v[0] + 1):
            if (position_1[x] != 'illegal'):
                continue
            temp = []
            while (True):
                s = Solver()
                s.add(global_transition_formula)
                s.add(Game["Constraint"])
                s.add(X == x)
                for i in temp:
                    s.add(Or(Y != i[0]))
                if (s.check() == sat):
                    m = s.model()
                    temp.append([m[Y].as_long()])
                else:
                    break
            is_losing = True
            s = Solver()
            s.add(Game["Constraint"])
            s.add(X == x)
            if (s.check() == unsat):
                continue
            for i in temp:
                if (position_1[i[0]] == 'illegal'):
                    position_1[i[0]] = isLossingState(i[0])
            for i in temp:
                is_losing = is_losing and not position_1[i[0]]
            if (is_losing):
                position_1[x] = True
            else:
                position_1[x] = False
        return position_1[v[0]]

    if(len(v) == 2):
        if(position_2[v[0]][v[1]] != 'illegal'):  # 已经访问过了的，直接访问值，没有的
            return position_2[v[0]][v[1]]
        for x in range(0, v[0]+1):  # 遍历所有的点去设置状态
            for y in range(0, v[1]+1):
                if(position_2[x][y] != 'illegal'):
                    continue
                temp = []  # 存放转移后的解 y y1即执行动作后的值
                while (True):
                    s = Solver()
                    s.add(global_transition_formula)
                    s.add(Game["Constraint"])
                    s.add(X == x, X1 == y)

                    for i in temp:
                        s.add(Or(Y != i[0], Y1 != i[1]))

                    if (s.check() == sat):
                        m = s.model()
                        temp.append([m[Y].as_long(), m[Y1].as_long()])  # 全局转移解
                    else:
                        break

                # print('438',temp) 存放状态 438 [[2, 1], [2, 0], [1, 1]]
                is_losing = True
                s = Solver()
                s.add(Game["Constraint"])
                s.add(X == x, X1 == y)
                if(s.check() == unsat):
                    continue
                for i in temp:
                    if(position_2[i[0]][i[1]] == 'illegal'):
                        position_2[i[0]][i[1]] = isLossingState(i[0], i[1])
                for i in temp:
                    is_losing = is_losing and not position_2[i[0]][i[1]]
                if (is_losing):
                    position_2[x][y] = True
                else:
                    position_2[x][y] = False
        return position_2[v[0]][v[1]]

# This function aims to enumerate states in an increasing order of the sum of values
#  of all state variables until find a suitable state
# 此函数旨在按值和的递增顺序枚举状态
# 直到找到合适的状态


def Findnum(ConcreteExs, expr):  # 遍历出一个不在反例集合中的状态（v1,v2)满足约束    (以后优化成满足约束且不满足表达式的状态)
    if (Game["var_num"] == 1):
        i = 2
        while(True):
            for v1 in range(0, i):
                flag12 = False
                for example in ConcreteExs:
                    if (v1 == example['Input'][c]):
                        flag12 = True
                if flag12 == False:
                    s = Solver()
                    s.add(Game["Constraint"])
                    s.add(X == v1)
                    if (s.check() == sat):
                        return v1
                    else:
                        continue
            i = i + 1
    if(Game["var_num"] == 2):
        i = 2
        while(True):
            for v1 in range(0, i):
                for v2 in range(0, i):
                    if v1+v2 == i:  # 遍历所有的v1v2=i的组合 按照size遍历
                        flag12 = False
                        # 改成 pt={c:v1,d:v2} if pt not in pts:
                        for example in ConcreteExs:
                            if (v1 == example['Input'][c] and v2 == example['Input'][d]):
                                flag12 = True
                        if flag12 == False:  # 不在反例集合中
                            s = Solver()
                            s.add(Game["Constraint"])  # 满足约束条件
                            s.add(X == v1, X1 == v2)
                            # 要求设置成不满足expr
                            if(s.check() == sat):
                                # print(expr)
                                # 加入判断是否与isLossingState相等
                                print("该轮枚举：", v1, v2)
                                boolTemp = isLossingState(v1, v2)
                                boolTemp2 = eval(str(expr).replace(
                                    str(X1), str(v2)).replace(str(X), str(v1)))
                                s = Solver()
                                if boolTemp == False:
                                    s.add(True, boolTemp2)
                                    if(s.check() == sat):
                                        return v1, v2
                                if boolTemp == True:
                                    s.add(True, boolTemp2)
                                    if(s.check() == unsat):
                                        return v1, v2
                                # if(boolTemp!=boolTemp2): #反例要求的是不等，不等才会把这个公式给排除
                                #     # print(v1,v2,"这一步有问题吗")
                                #     return v1, v2
                            else:
                                continue
            i = i+1


# 下面是生成获胜公式的过程
# 这个过程将持续到找到获胜的公式
# 这个过程会产生失败的公式，而胜出的公式是它的否定
# 下面是优化过程—— refine the winning formula
e = 1
num = 1
num1 = 0
flag = 1
O = Bool('O')

while(True):  # 合成制胜公式
    last_e = e
    # 枚举的是必败条件的表达式[X == X, Y == Y] [X != X1, Y != Y1] [X == X1 + 1, Y == Y1 + 1]....
    e = Enumerate_algorithm(num, 'Bool')
    # e=[(X + X1)%3 == 0, (Y + Y1)%3 == 0]
    print("枚举出候选的必败态：", e)
    print('反例集合', ConcreteExs)
    print("反例的个数",len(ConcreteExs))
    s = Solver()

    if(e != last_e):  # 枚举出的是新的表达式  （待优化，将判断是否重复设计到枚举函数中去）
        print(e[0], e[1])
        s.set('timeout', 60000)
        s.add(Or(And(Game["Terminal_Condition"], Not(e[0])),  # 必败态公式 是定义7的取反  （考虑化简）
                Not(Implies(And(e[0], Game["Constraint"]), ForAll(
                    [Y, Y1], Implies(global_transition_formula, Not(e[1]))))),
                Not(Implies(And(Not(e[0]), Game["Constraint"]), Exists([Y, Y1], And(global_transition_formula, e[1]))))))

    # print(s)
    # print("528",s.check())

    # 返回之前的方法，从这里tab
        if(s.check() == unsat):  # 必败态取非就是必胜态了呀
            losing_formula = e[0]
            losing_formula_Y = e[1]
            # print("544",losing_formula,losing_formula_Y);
            print(
                '-----------------------------------------------------------------------------')
            print("The Winning formula of this game is:", Not(losing_formula))
            generate_winning_formula_time = (
                time.time() - start_winning_formula_time)
            print("Time to generate the winning formula:",
                generate_winning_formula_time)
            break
        elif(s.check() == unknown):  # 指数 找出num4,num5非illegal的
            if(Game["var_num"] == 1):
                while True:
                    num4 = Findnum(ConcreteExs,e[0])
                    if isLossingState(num4) == 'illegal':
                        continue
                    else:
                        break
            if(Game["var_num"] == 2):
                while True:
                    num4, num5 = Findnum(ConcreteExs,e[0])
                    if isLossingState(num4, num5) == 'illegal':
                        continue
                    else:
                        break
        else(s.check() == sat):  # 找出num4,num5非illegal的
            # m = s.model()
            if (Game["var_num"] == 1):
                #     num4 = m[X].as_long()
                #     if isLossingState(num4) == 'illegal':
                # while True:
                num4 = Findnum(ConcreteExs, e[0])
                # if isLossingState(num4,e) == 'illegal':
                #     continue
                # else:
                #     break
            if (Game["var_num"] == 2):
                #     num4 = m[X].as_long()
                #     num5 = m[X1].as_long()
                #     #为什么求这个解？
                #     print("：",num4,num5)
                #     #p判断这个pt是否已经在其他的公式中枚举过了，枚举过了就不要取这个点了
                #     if isLossingState(num4, num5) == 'illegal':
                # while True:
                num4, num5 = Findnum(ConcreteExs, e[0])
                # if isLossingState(num4, num5) == 'illegal':
                #     continue
                # else:
                #     break
    else:  # 当枚举出的和之前的相等时，找出合适的状态num4,num5
        print("新的方法，不会执行这个的，看到这条说明有错误")
        while True:
            if (Game["var_num"] == 1):
                num4 = Findnum(ConcreteExs,e[0])
                if isLossingState(num4) == 'illegal':
                    continue
                else:
                    break
            if (Game["var_num"] == 2):
                num4, num5 = Findnum(ConcreteExs,e[0])
                if isLossingState(num4, num5) == 'illegal':
                    continue
                else:
                    break
    if (Game["var_num"] == 1):
        if ({'Input': {c: num4}, 'Output': isLossingState(num4)}) not in ConcreteExs:
            ConcreteExs.append(
                {'Input': {c: num4}, 'Output': isLossingState(num4)})
            goal['value'].append(isLossingState(num4))
            num = num + 1
    if (Game["var_num"] == 2):
        if ({'Input': {c: num4, d: num5}, 'Output': isLossingState(num4, num5)}) not in ConcreteExs:
            ConcreteExs.append(
                {'Input': {c: num4, d: num5}, 'Output': isLossingState(num4, num5)})
            goal['value'].append(isLossingState(num4, num5))
            num = num + 1
            # print('617:',goal)
# ------------------------------------------------------------------


def Losing_formula():
    return losing_formula


def Winning_formula():
    return Not(losing_formula)


def Losing_formula_Y():
    return losing_formula_Y


def Winning_formula_Y():
    return Not(losing_formula_Y)


start_refine = time.time()

# The following function aim to refine the winning formula, it will return the covers of winning formula
# 以下函数的目的是细化优胜公式，返回致胜公式的覆盖


def refine_the_winning_formula(Losing_formula):
    C = str(Losing_formula)
    # print('612',C)    X == X1 + 1
    C = C.replace(' ', '')  # X==X1+1
    Ct = []
    # gou'zhao
    if (C.find('And') == -1 and C.find('Or') == -1):  # 表达式没有and or
        if (C.find('==') != -1 and (type(eval(C[(C.find('==') + 2):])) == type(1)) and C.find('%') == -1):
            Ct = []
            Ct.append(C.replace('==', '<'))
            Ct.append(C.replace('==', '>'))
        elif (C.find('==') != -1 and (type(eval(C[(C.find('==') + 2):])) == type(X)) and C.find('%') == -1):
            Ct = []
            Ct.append(C.replace('==', '<'))
            Ct.append(C.replace('==', '>'))
        # a%b==c
        elif (C.find('%') != -1 and (type(eval(C[(C.find('==') + 2):])) == type(1))):
            Ct = []
            num = eval(C[(C.find('%') + 1):C.find('==')]) - 1  # b
            num_original = eval(C[(C.find('==') + 2):])  # c
            while (num >= 0):
                if (num != num_original):  # b!=c and b>=0
                    C = C[:C.find('==') + 2]
                    C = C + str(num)     # a+b
                    Ct.append(C)
                    # Ct.append(C.replace(C[(C.find('==') + 2):], str(num)))
                num = num - 1
    else:
        if ((C.find('X') != -1 and C.find('X1') == -1) or (C.find('X') == -1 and C.find('X1') != -1)):
            if (C.find('%') != -1 and (type(eval(C[(C.find('==') + 2):C.find(',')])) == type(1)) and C.find(
                    'Or') != -1):
                Ct = []
                num = eval(C[(C.find('%') + 1):C.find('==')]) - 1
                prnum = []
                pre = C.find('==')
                while (pre != -1):
                    prnum.append(eval(C[pre + 2]))
                    pre = C.find('==', pre + 1)
                # print(prnum)
                while (num >= 0):
                    if (num not in prnum):
                        Ct.append(C[C.find('X'):C.find(',')].replace(
                            C[C.find('==') + 2], str(num)))
                    num = num - 1
        else:
            if (C.find('And') != -1):
                C1 = C
                C1 = C1.replace('And', 'Or')
                C1 = C1.replace('==', '!=')
                C1 = C1.replace('Or(', '')
                C1 = C1.replace(')', '')
                Ct = C1.split(',')
    refine_time_used = (time.time() - start_refine)
    print("Refine Time used:", refine_time_used)
    print("Covers of this game:", Ct)
    refinement = []
    for i in Ct:
        i = eval(i)
        refinement.append(i)
    return refinement, refine_time_used

# This function is an recursive algorithm that to find the corresponding action parameter of a state
# 此函数是一种递归算法，用于查找状态的相应动作参数,找不到返回“no suitable k_num”

# 求出结果一动作下的结果--pt --goal


def f_strategy(action_precondition, action_transition_formula, action_constraint, *v):
    s = Solver()
    s.add(Not(Winning_formula_Y()))
    s.add(action_precondition)
    s.add(action_transition_formula)
    s.add(action_constraint)
    s.add(X == v[0])
    if(Game["var_num"] == 2):
        s.add(X1 == v[1])
        # print("700", v[0], v[1])
    # print(s.check())
    if(s.check() == sat):
        m = s.model()
        return m[k_num].as_long()
    else:
        return "no suitable k_num"

# 找位置


def findnum_strategy(cover, ConcreteExs, action_constraint):
    s = Solver()
    s.add(cover)
    s.add(action_constraint)
    if(Game["var_num"] == 1):
        for i in ConcreteExs:
            s.add(Or(X != i['Input'][c]))
    if(Game["var_num"] == 2):
        for i in ConcreteExs:
            s.add(Or(X != i['Input'][c], X1 != i['Input'][d]))
    s.check()
    m = s.model()
    if(Game["var_num"] == 1):
        return m[X].as_long()
    if (Game["var_num"] == 2):
        return m[X].as_long(), m[X1].as_long()


Winning_strategy = []
refinement, refine_time_used = refine_the_winning_formula(Losing_formula())
# refinement,refine_time_used=refine_the_winning_formula("X==X1+1")

# The following is the process of generating the winning strategy for every covers of winning formula
# This process will choose the corresponding action and action parameter of every cover
# 下面是为每个获胜公式的块生成制胜策略的过程
# 此过程将选择每个块对应的动作和动作参数
for cover in refinement:
    # print("725cover:",cover)
    s = Solver()
    s.add(cover)
    s.add(Game["Constraint"])
    if(s.check() == unsat):  # 判断cover是否满足约束条件
        continue
    # The type of the initial search target is int
    # 初始搜索的目标是int
    ConcreteExs.clear()
    goal = {'value': [], 'type': ''}
    goal['type'] = 'Int'  # 去枚举int型的表达式 如eat(X) eat(1)
    for action in actions:
        # print("738动作",action["action_name"])
        it_mum = 1
        e = 1
        while (True):
            # print(ConcreteExs)
            last_e = e
            e = Enumerate_algorithm(it_mum, 'Int')
            print(e)
            e = e[0]  # z3表达式[x,x] 一个
            # print("枚举的数值表达式", e)
            if(type(e) == type(X)):
                e = simplify(e)

            s = Solver()
            if (str(e) != str(last_e)):
                action_temp = copy.deepcopy(action)
                if (str(action_temp).find("k_num") != -1):  # 用枚举得int代替action中的K_num
                    action_temp = eval(
                        str(action_temp).replace("k_num", '('+str(e)+')'))
                # This is the constrains of this cover
                s.add(Game["Constraint"])  # 定义7
                s.add(Not(Implies(And(cover, Game["Constraint"]), And(action_temp["precondition"],
                                                                      ForAll([Y, Y1], Implies(action_temp["transition_formula"], Not(Winning_formula_Y())))))))

                if (s.check() == unsat):
                    Winning_strategy.append(
                        [cover, action["action_name"]+"("+str(e)+")"])
                    # print("find")
                    # print('910Winning_strategy', Winning_strategy)
                    break
                else:
                    m = s.model()  # model模型解
                    # print('774模型解:', m)

                    num1 = m[X].as_long()
                    if(Game["var_num"] == 2):
                        num2 = m[X1].as_long()
                    # print("777num", num1, num2)

                    s_tem = Solver()
                    s_tem.add(cover)
                    s_tem.add(X == num1)
                    if (Game["var_num"] == 2):
                        s_tem.add(X1 == num2)
                    if(s_tem.check() != sat):
                        if (Game["var_num"] == 1):
                            num1 = findnum_strategy(
                                cover, ConcreteExs, Game["Constraint"])
                        if (Game["var_num"] == 2):
                            num1, num2 = findnum_strategy(
                                cover, ConcreteExs, Game["Constraint"])
                            # print("785找新的num值：", num1, "  ", num2)
                    if(f_strategy(action["precondition"], action["transition_formula"], Game["Constraint"], num1, num2) == "no suitable k_num"):
                        print("794no suitable k_num")
                        break
                    result = f_strategy(
                        action["precondition"], action["transition_formula"], Game["Constraint"], num1, num2)
            else:
                print('two expresion equal')
                # 草率了，这里需要判断是否只有num1
                if(f_strategy(action["precondition"], action["transition_formula"], Game["Constraint"], num1, num2) == "no suitable k_num"):
                    print("798no suitable k_num")
                    break
                if(Game["var_num"] == 1):
                    num1 = findnum_strategy(
                        cover, ConcreteExs, Game["Constraint"])  # 满足条件且不在反例集和中的
                if(Game["var_num"] == 2):
                    num1, num2 = findnum_strategy(
                        cover, ConcreteExs, Game["Constraint"])
                result = f_strategy(
                    action["precondition"], action["transition_formula"], Game["Constraint"], num1, num2)
            if (Game["var_num"] == 1):
                if ({'Input': {c: num1}, 'Output': result}) not in ConcreteExs:
                    ConcreteExs.append({'Input': {c: num1}, 'Output': result})
                    goal['value'].append(result)
                    it_mum = it_mum + 1
            if(Game["var_num"] == 2):  # 跟新ConcreteExs
                if ({'Input': {c: num1, d: num2}, 'Output': result}) not in ConcreteExs:
                    ConcreteExs.append(
                        {'Input': {c: num1, d: num2}, 'Output': result})
                    goal['value'].append(result)
                    print(ConcreteExs)
                    it_mum = it_mum + 1

# ---------------------------------------------------------------------------------------------
total_time_use = (time.time() - start_total)
print("------------------------------------------------------------------------------------------------")
print("winning strategy:", Winning_strategy)
# for i in Winning_strategy:
#     print(i)
print("Winning strategy Time used:", total_time_use -
      refine_time_used-generate_winning_formula_time)
print("Total Time used:", total_time_use)
